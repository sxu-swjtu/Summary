# 生成标签

> `lable = torch.randint(high=100, size=(10,1)).cuda()`
>
> - 原型：torch.randint(low=0, high, size)                   # size:(N,1)，表示生成N个样本的标签
>   - 生成形状为size的Tensor，其中每个元素取值为[0,100)之间的整数  （表示100个类）



---



# FC权重（the last）

> - 定义：`self.weight = torch.nn.Parameter(torch.FloatTensor(out_features, in_features))`
>   - Parameter将一个不可训练的Tensor转换为可以训练的类型parameter，并且在参数优化时可以进行优化
> - 初始化：`torch.nn.init.xavier_uniform_(self.weight)`
>   - 使之服从均匀分布
>   - 补：`torch.nn.init.xavier_normal_()` # 服从正态分布



---



# torch.nn.functional 

> ```python
> import torch.nn.functional as F
> 
> - F.normalize(x): 若x为向量，则对其进行L2归一化；若x为矩阵，则将每一行视为一个向量，对每个向量进                     行L2归一化   [x,y]  -> [x/sprt(x^2+y^2),y/sqrt(x^2+y^2)]
> - F.linear(x, weight, bias=None): y = x * weight^T(矩阵乘法) + bias
> ```
>
> 



----



#  torch

- torch.zeros(shape)

  - > one_hot = torch.zeros(cosine.size(), device='cuda')   # 若想使得结果在GPU上，必须添加device属性
    >
    > one_hot.scatter_(1, label.view(-1, 1).long(), 1)   # 完成标签的One-Hot编码 
    >
    > - 若label内容都为torch.int类型，则不用加long()方法

- torch.zeros_like(x)

  - > 参数为具体的数据，若该数据在GPU上，则产生的同样形状的 零Tensor仍在GPU上

- torch.diag(input,diagonal=0,out=None)

  - > 如果input为一个1D张量(向量)，则返回以该张量为对角线的2D方阵
    >
    > 如果input为一个2D张量(矩阵)，则返回以该矩阵的对角线组成的1D张量

  - diagonal = 0：主对角线

  - diagonal > 0：主对角线之上

  - diagonal < 0：主对角线之下

  - > 求每个样本所对应的cos值：`cos = torch.diag(cosine.mm(one_hot.t()))`
    >
    > - 设2个样本，3个类，则由 cosine = F.linear(F.normalize(input), F.normalize(weight))得到 2*3的矩阵
    > - one_hot.t()为标签的独热编码矩阵的转置，形状为 3*2
    > - mm()为矩阵的乘法，矩阵相乘后结果为2*2，对角线恰好为每个样本所对应的cos值

- torch.where(条件, a, b)

  - 根据条件合并两个Tensor，若条件满足，使用a中对应元素，若条件不满足，使用b中元素

  - > c = torch.where(条件, a, b)  # 条件为Tensor，形状与a,b相同；内容为bool
    >
    > - 若两个Tensor形状相同，内容均为bool值，则两个Tensor直接可以使用& | 表示逻辑运算





---

# numpy

## 从正态分布取样

> `data = np.random.normal(loc=0, scale=1,size=100)`
>
> - 从均值为0，方差为1的正态分布中取100个样本



## 高斯混合模型使用

> ```python
> from sklearn.mixture import GaussianMixture
> 
> # 生成数据
> data1 = np.random.normal(loc=-0.2, scale=0.2, size=70000)
> data2 = np.random.normal(loc=0.7, scale=0.2, size=70000)
> data = np.hstack((data1, data2)) # 将两组数组组合在一起
> 
> gmm = GaussianMixture(n_components=2) #定义模型(该模型由2个高斯模型叠加而成)
> gmm.fit(data.reshape(-1, 1)) #根据数据拟合模型参数
> means = gmm.means_  # 两个高斯模型分别的均值
> means = np.sort(means, axis=0)  # 排序
> print('最大的均值:', means[1][0])
> ```



## 保存数据

> `np.save(os.path.join(hist_save_dir, 'data'), data)`
>
> - 生成一个扩展名为npy的文件
> - 该文件的读取：`data = np.load(路径)`



---





# OS

## 生成目录

> ```python
> import os
> from datetime import datetime
> 
> # 使用os.path.join将两个字符串拼接，形成目录路径(join会在两个字符串之间用‘\’连接)
> # .\histogrampics\20200226_225240
> hist_save_dir = os.path.join('.\histogrampics',datetime.now().strftime('%Y%m%d_%H%M%S'))
> 
> if not os.path.exists(hist_save_dir):  如果目录不存在就生成该目录
>      os.makedirs(hist_save_dir)
> ```
>
> - os.makedirs()：可生成任何层次的目录
> - os.mkdir()：只能生成一层目录
>   - 如过histogrampics目录不存在，则相当于生成两级目录，此时使用mkdir将会报错





# matplotlib

- 保存图片：`plt.savefig(os.path.join(目录路径, 'pic.jpg'))` `plt.close()`
- 绘制直方图：`plt.hist(data, bins=200)`  `plt.show()`
  - bins表示将data按照值大小平均分成200个组，分别统计处于每个组范围内的频数